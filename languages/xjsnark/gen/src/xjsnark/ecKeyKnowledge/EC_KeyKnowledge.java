package xjsnark.ecKeyKnowledge;

/*Generated by MPS */

import backend.structure.CircuitGenerator;
import backend.config.Config;
import backend.eval.SampleRun;
import java.math.BigInteger;
import backend.auxTypes.FieldElement;
import backend.auxTypes.UnsignedInteger;
import backend.auxTypes.Bit;
import backend.auxTypes.ConditionalScopeTracker;
import backend.eval.CircuitEvaluator;

public class EC_KeyKnowledge extends CircuitGenerator {



  public static void main(String[] args) {
    // This is the java main method. Its purpose is to make the Progam runnable in the environment 
    // This method can be left empty, or used to set Configuration params (see examples) 
    Config.hexOutputEnabled = true;

    // In the above example with a 256-bit exponent, we don't need to check against a 0/0 case. 
    // Even if sk was set to be the order, we would get a non-zero divided by zero case in the last iteration, 
    //  which is unsatisfiable.  
    // The checks are a bit costly for non-native fields when they are out of range, as we have to check if  
    //  the modulus divides the denominator, so we disable the checks here.  
    Config.enforceInternalDivisionNonZeroChecks = false;
    new EC_KeyKnowledge();
  }

  public EC_KeyKnowledge() {
    super("EC_KeyKnowledge");
    __generateCircuit();
    this.__evaluateSampleRun(new SampleRun("Sample_Run1", true) {
      public void pre() {
        pk_x.mapValue(new BigInteger("a3a27c5332acd8e6a15fab4135e21c7ade4230168df103809abc995244bbd092", 16), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        pk_y.mapValue(new BigInteger("134866b732f47928ba02efb9f1905d3c1525e221b43015d5c97ed93eeb5d543", 16), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        sk.mapValue(new BigInteger("89552050406086998614610183528124098025137729044603000209903360664612891430799"), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
      }
      public void post() {
        //  No outputs to print. No failed assertions are expected 
        System.out.println("If no failed assertions appear, everything looks to be OK for this circuit.");
      }

    });

  }



  public void __init() {
    pk_x = new FieldElement(new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"), new BigInteger("0"));
    pk_y = new FieldElement(new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"), new BigInteger("0"));
    sk = new UnsignedInteger(256, new BigInteger("0"));
  }

  public FieldElement pk_x;
  public FieldElement pk_y;
  public UnsignedInteger sk;

  @Override
  public void __defineInputs() {
    super.__defineInputs();
    pk_x = FieldElement.createInput(this, new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"));
    pk_y = FieldElement.createInput(this, new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"));















  }
  @Override
  public void __defineOutputs() {
    super.__defineOutputs();









  }
  @Override
  public void __defineVerifiedWitnesses() {
    super.__defineVerifiedWitnesses();

    sk = UnsignedInteger.createVerifiedWitness(this, 256);


















  }
  @Override
  public void __defineWitnesses() {
    super.__defineWitnesses();

















  }
  public void outsource() {

    // EC generator point 
    FieldElement base_x = FieldElement.instantiateFrom(new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"), "48439561293906451759052585252797914202762949526041747995844080717082404635286").copy();
    FieldElement base_y = FieldElement.instantiateFrom(new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"), "36134250956749795798585127919587881956611106672985015071877198253568414405109").copy();

    // Additional safety checks (just precautionary) 
    UnsignedInteger order = UnsignedInteger.instantiateFrom(256, "115792089210356248762697446949407573529996955224135760342422259061068512044369").copy(256);
    CircuitGenerator.__getActiveCircuitGenerator().__addOneAssertion((sk.isLessThan(order)).and((sk.isNotEqualTo(UnsignedInteger.instantiateFrom(256, 0)))).getWire());

    FieldElement[][] table = (FieldElement[][]) FieldElement.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{256, 2}, new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"));
    table[0][0].assign(base_x);
    table[0][1].assign(base_y);

    // The next loop is for preprocessing, and will be operating on constants in the circuit 
    // This won't add any constraints, but might take time initially as BigInteger operations are expensive due to  
    // constants being heavily splitted into multiple wires in the circuit. 
    // This can be replaced by independent faster native java code computing constants, and just doing assignments  
    // in the end but this was left for testing purposes. 
    System.out.println("Precomputing constants (might take time in this version -- see note in the code).. ");
    for (int i = 1; i < 256; i++) {
      table[i] = doublePoint(table[i - 1][0].copy(), table[i - 1][1].copy());
    }

    // a boolean to keep track when it's safe to apply the addition formula of affine points 
    Bit init = Bit.instantiateFrom(false).copy();

    FieldElement p_x = new FieldElement(new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"), new BigInteger("0"));
    FieldElement p_y = new FieldElement(new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"), new BigInteger("0"));

    for (int i = 0; i < 256; i++) {
      {
        Bit bit_a0bb0w = sk.getBitElements()[i].copy();
        boolean c_a0bb0w = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0bb0w);
        if (c_a0bb0w) {
          if (bit_a0bb0w.getConstantValue()) {
            {
              Bit bit_a0a0a2a0a72a22 = init.copy();
              boolean c_a0a0a2a0a72a22 = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0a0a2a0a72a22);
              if (c_a0a0a2a0a72a22) {
                if (bit_a0a0a2a0a72a22.getConstantValue()) {
                  FieldElement[] r = addPoints(p_x.copy(), p_y.copy(), table[i][0].copy(), table[i][1].copy());
                  p_x.assign(r[0]);
                  p_y.assign(r[1]);
                } else {
                  init.assign(Bit.instantiateFrom(true));
                  p_x.assign(table[i][0]);
                  p_y.assign(table[i][1]);

                }
              } else {
                ConditionalScopeTracker.pushMain();
                ConditionalScopeTracker.push(bit_a0a0a2a0a72a22);
                FieldElement[] r = addPoints(p_x.copy(), p_y.copy(), table[i][0].copy(), table[i][1].copy());
                p_x.assign(r[0]);
                p_y.assign(r[1]);

                ConditionalScopeTracker.pop();

                ConditionalScopeTracker.push(new Bit(true));

                init.assign(Bit.instantiateFrom(true));
                p_x.assign(table[i][0]);
                p_y.assign(table[i][1]);
                ConditionalScopeTracker.pop();
                ConditionalScopeTracker.popMain();
              }

            }
          } else {

          }
        } else {
          ConditionalScopeTracker.pushMain();
          ConditionalScopeTracker.push(bit_a0bb0w);
          {
            Bit bit_a0a0bb0w = init.copy();
            boolean c_a0a0bb0w = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0a0bb0w);
            if (c_a0a0bb0w) {
              if (bit_a0a0bb0w.getConstantValue()) {
                FieldElement[] r = addPoints(p_x.copy(), p_y.copy(), table[i][0].copy(), table[i][1].copy());
                p_x.assign(r[0]);
                p_y.assign(r[1]);
              } else {
                init.assign(Bit.instantiateFrom(true));
                p_x.assign(table[i][0]);
                p_y.assign(table[i][1]);

              }
            } else {
              ConditionalScopeTracker.pushMain();
              ConditionalScopeTracker.push(bit_a0a0bb0w);
              FieldElement[] r = addPoints(p_x.copy(), p_y.copy(), table[i][0].copy(), table[i][1].copy());
              p_x.assign(r[0]);
              p_y.assign(r[1]);

              ConditionalScopeTracker.pop();

              ConditionalScopeTracker.push(new Bit(true));

              init.assign(Bit.instantiateFrom(true));
              p_x.assign(table[i][0]);
              p_y.assign(table[i][1]);
              ConditionalScopeTracker.pop();
              ConditionalScopeTracker.popMain();
            }

          }

          ConditionalScopeTracker.pop();

          ConditionalScopeTracker.push(new Bit(true));

          ConditionalScopeTracker.pop();
          ConditionalScopeTracker.popMain();
        }

      }
    }
    p_x.forceEqual(pk_x);
    p_y.forceEqual(pk_y);
  }
  private FieldElement[] addPoints(FieldElement x1, FieldElement y1, FieldElement x2, FieldElement y2) {
    FieldElement lambda = (y2.subtract(y1)).div((x2.subtract(x1))).copy();
    FieldElement xr = lambda.mul(lambda).subtract(x1).subtract(x2).copy();
    FieldElement yr = lambda.mul((x1.subtract(xr))).subtract(y1).copy();
    return new FieldElement[]{xr.copy(), yr.copy()};
  }
  private FieldElement[] doublePoint(FieldElement x1, FieldElement y1) {
    FieldElement lambda = (FieldElement.instantiateFrom(new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"), 3).mul(x1).mul(x1).add(FieldElement.instantiateFrom(new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"), -3))).div((FieldElement.instantiateFrom(new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"), 2).mul(y1))).copy();
    FieldElement xr = lambda.mul(lambda).subtract(x1.mul(FieldElement.instantiateFrom(new BigInteger("115792089210356248762697446949407573530086143415290314195533631308867097853951"), 2))).copy();
    FieldElement yr = lambda.mul((x1.subtract(xr))).subtract(y1).copy();
    return new FieldElement[]{xr.copy(), yr.copy()};
  }

  public void __generateSampleInput(CircuitEvaluator evaluator) {
    __generateRandomInput(evaluator);
  }

}
