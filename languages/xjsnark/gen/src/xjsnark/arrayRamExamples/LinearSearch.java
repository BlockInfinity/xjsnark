package xjsnark.arrayRamExamples;

/*Generated by MPS */

import backend.structure.CircuitGenerator;
import backend.config.Config;
import backend.eval.SampleRun;
import java.math.BigInteger;
import backend.auxTypes.UnsignedInteger;
import backend.auxTypes.Bit;
import util.Util;
import backend.auxTypes.ConditionalScopeTracker;
import backend.auxTypes.FieldElement;
import backend.eval.CircuitEvaluator;

public class LinearSearch extends CircuitGenerator {



  public static void main(String[] args) {
    // This is the java main method. Its purpose is to make the Progam runnable in the environment 
    // This method can be left empty, or used to set Configuration params (see examples) 
    Config.inputVerbose = false;
    new LinearSearch();
  }

  public LinearSearch() {
    super("LinearSearch");
    __generateCircuit();
    this.__evaluateSampleRun(new SampleRun("Sample_Run1", true) {
      public void pre() {
        for (int i = 0; i < SIZE; i++) {
          array[i].mapValue(BigInteger.valueOf(i), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        }
        element.mapValue(BigInteger.valueOf(5), CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
      }
      public void post() {
        System.out.println("Element Found = " + isFound.getValueFromEvaluator(CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator()).equals(BigInteger.ONE));
      }

    });

  }



  public void __init() {
    array = (UnsignedInteger[]) UnsignedInteger.createZeroArray(CircuitGenerator.__getActiveCircuitGenerator(), new int[]{SIZE}, 32);
    element = new UnsignedInteger(32, new BigInteger("0"));
    isFound = Bit.instantiateFrom(false).copy();
  }

  public UnsignedInteger[] array;
  public UnsignedInteger element;
  public Bit isFound;

  public static int SIZE = 1024;
  @Override
  public void __defineInputs() {
    super.__defineInputs();
    element = UnsignedInteger.createInput(this, 32);



    array = (UnsignedInteger[]) UnsignedInteger.createInputArray(CircuitGenerator.__getActiveCircuitGenerator(), Util.getArrayDimensions(array), 32);












  }
  @Override
  public void __defineOutputs() {
    super.__defineOutputs();



    Bit.makeOutput(this, isFound);






  }
  public void outsource() {

    // Less Efficient way 

    // More efficient way 
    efficientLinearSearch();

  }
  private void naiveLinearSearch() {
    for (int i = 0; i < SIZE; i++) {
      {
        Bit bit_a0a0k = array[i].isEqualTo(element).copy();
        boolean c_a0a0k = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_a0a0k);
        if (c_a0a0k) {
          if (bit_a0a0k.getConstantValue()) {
            isFound.assign(Bit.instantiateFrom(true));
          } else {

          }
        } else {
          ConditionalScopeTracker.pushMain();
          ConditionalScopeTracker.push(bit_a0a0k);
          isFound.assign(Bit.instantiateFrom(true));

          ConditionalScopeTracker.pop();

          ConditionalScopeTracker.push(new Bit(true));

          ConditionalScopeTracker.pop();
          ConditionalScopeTracker.popMain();
        }

      }
    }
  }
  private void efficientLinearSearch() {

    // Use operations in native field to get a better circuit. (native is defined in FieldDefTable) 
    // The reasons we cast to F_native is that doing minus and product operations 
    // for uint_32 strictly enforces the rules of type uint_32 which leads to extra constraints. 
    // Note: this method should not be used for integer and field types that can have values outside F_native 

    FieldElement product = FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 1).copy();
    FieldElement elm = FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), element).copy();
    for (int i = 0; i < SIZE; i++) {
      product.assign(product.mul((FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), array[i]).subtract(elm))));
    }
    isFound.assign(product.isEqualTo(FieldElement.instantiateFrom(new BigInteger("21888242871839275222246405745257275088548364400416034343698204186575808495617"), 0)));

    // We've implemented front end logic that can transform methods like naiveLinearSearch 
    // to efficientLinearSearch but it's not activated yet. It won't also cover all cases. 
  }

  public void __generateSampleInput(CircuitEvaluator evaluator) {
    __generateRandomInput(evaluator);
  }

}
