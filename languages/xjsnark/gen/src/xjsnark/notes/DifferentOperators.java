package xjsnark.notes;

/*Generated by MPS */

import backend.structure.CircuitGenerator;
import backend.eval.SampleRun;
import java.math.BigInteger;
import backend.auxTypes.UnsignedInteger;
import backend.auxTypes.Bit;
import backend.auxTypes.ConditionalScopeTracker;
import backend.eval.CircuitEvaluator;

public class DifferentOperators extends CircuitGenerator {



  public static void main(String[] args) {
    // This is the java main method. Its purpose is to make the Progam runnable in the environment 
    // This method can be left empty, or used to set Configuration params (see examples) 
    new DifferentOperators();
  }

  public DifferentOperators() {
    super("DifferentOperators");
    __generateCircuit();
    this.__evaluateSampleRun(new SampleRun("Sample_Run1", true) {
      public void pre() {
        in1.mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());
        in2.mapValue(BigInteger.ONE, CircuitGenerator.__getActiveCircuitGenerator().__getCircuitEvaluator());

      }
      public void post() {
      }

    });

  }



  public void __init() {
    in1 = new UnsignedInteger(32, new BigInteger("0"));
    in2 = new UnsignedInteger(32, new BigInteger("0"));
    out1 = new UnsignedInteger(32, new BigInteger("0"));
    out2 = new UnsignedInteger(32, new BigInteger("0"));
    out3 = new UnsignedInteger(32, new BigInteger("0"));
  }

  public UnsignedInteger in1;
  public UnsignedInteger in2;
  public UnsignedInteger out1;
  public UnsignedInteger out2;
  public UnsignedInteger out3;

  @Override
  public void __defineInputs() {
    super.__defineInputs();
    in1 = UnsignedInteger.createInput(this, 32);
    in2 = UnsignedInteger.createInput(this, 32);















  }
  @Override
  public void __defineOutputs() {
    super.__defineOutputs();
    UnsignedInteger.makeOutput(this, out1);
    UnsignedInteger.makeOutput(this, out2);
    UnsignedInteger.makeOutput(this, out3);









  }
  public void outsource() {

    // to check equality in the circuit use EQ instead of == 
    {
      Bit bit_c0o = in1.isEqualTo(in2).copy();
      boolean c_c0o = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_c0o);
      if (c_c0o) {
        if (bit_c0o.getConstantValue()) {
          out1.assign(new UnsignedInteger(1, new BigInteger("1")), 32);
        } else {
          out1.assign(new UnsignedInteger(2, new BigInteger("2")), 32);

        }
      } else {
        ConditionalScopeTracker.pushMain();
        ConditionalScopeTracker.push(bit_c0o);
        out1.assign(new UnsignedInteger(1, new BigInteger("1")), 32);

        ConditionalScopeTracker.pop();

        ConditionalScopeTracker.push(new Bit(true));

        out1.assign(new UnsignedInteger(2, new BigInteger("2")), 32);
        ConditionalScopeTracker.pop();
        ConditionalScopeTracker.popMain();
      }

    }

    // to check InEquality in the circuit use NEQ instead of != 
    {
      Bit bit_f0o = in1.isNotEqualTo(in2).copy();
      boolean c_f0o = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_f0o);
      if (c_f0o) {
        if (bit_f0o.getConstantValue()) {
          out2.assign(new UnsignedInteger(1, new BigInteger("1")), 32);
        } else {
          out2.assign(new UnsignedInteger(2, new BigInteger("2")), 32);

        }
      } else {
        ConditionalScopeTracker.pushMain();
        ConditionalScopeTracker.push(bit_f0o);
        out2.assign(new UnsignedInteger(1, new BigInteger("1")), 32);

        ConditionalScopeTracker.pop();

        ConditionalScopeTracker.push(new Bit(true));

        out2.assign(new UnsignedInteger(2, new BigInteger("2")), 32);
        ConditionalScopeTracker.pop();
        ConditionalScopeTracker.popMain();
      }

    }

    // Boolean/logical operators are different 
    // We use NOT instead of ! 
    // For && and ||, we use AND and OR instead 
    {
      Bit bit_k0o = ((in1.isNotEqualTo(in2)).or(((in2.isEqualTo(out1)).and((out1.isEqualTo(out2)))))).inv().copy();
      boolean c_k0o = CircuitGenerator.__getActiveCircuitGenerator().__checkConstantState(bit_k0o);
      if (c_k0o) {
        if (bit_k0o.getConstantValue()) {
          out3.assign(new UnsignedInteger(2, new BigInteger("2")), 32);
        } else {

        }
      } else {
        ConditionalScopeTracker.pushMain();
        ConditionalScopeTracker.push(bit_k0o);
        out3.assign(new UnsignedInteger(2, new BigInteger("2")), 32);

        ConditionalScopeTracker.pop();

        ConditionalScopeTracker.push(new Bit(true));

        ConditionalScopeTracker.pop();
        ConditionalScopeTracker.popMain();
      }

    }
    // Note: The precedence of the NOT operator is different from usual due to difficulty in setting the precdence of  
    // new unary operators in this environment. 
    // Use parentheses to control the behavior. 
    // For example for an expression like !x && y, it should be written as (NOT x) AND y. 


    // note that integer bitwise operators were overrriden (check the SHA256 example) 

  }

  public void __generateSampleInput(CircuitEvaluator evaluator) {
    __generateRandomInput(evaluator);
  }

}
